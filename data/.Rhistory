y = RMSE,
group = name,
colour = name
)
) +
geom_point(size = 5) +
geom_line() +
labs(x = "Date",
title = "RMSE of Model Forecasts",
colour = "AR Model",
) +
theme(legend.position=c(0.2,0.8)) +
scale_colour_discrete(labels=c('AR1 Model', 'AR2 Model'))
#### Answer ####
# The graph of RMSE shows that the two forecasts diverge at the seventh month.
# Back in Lab 3 when we compared the values of the forecasts with the observed values,
# the AR model that accounted for NDVI and rain made predictions that were closer to the
# observed values from the seventh month and beyond compared to the AR model that just accounted
# for rain. Therefore, that's why the RMSE is different between the two forecasts.
#### Observed vs Predicted Plots ####
# Extracting the observed values of the forecasting window
NDVI.obs.values.window <- portal.data$NDVI[264:273]
NDVI.obs.values.window
# NDVI model with respect to NDVI(t-1)
plot(NDVI.ar1.forecast ~ NDVI.obs.values.window,
xlab = "NDVI Observed Data",
ylab = "NDVI AR1 Forecast Data",
main = "Relationship Between Forecast and Observed NDVI Data from AR1 Model",
xlim = c(0.1,0.4),
ylim = c(0.1,0.4)
)
abline(a=0, b=1)
# NDVI model with respect to NDVI(t-1) and rain(t-1)
plot(NDVI.ar2.forecast ~ NDVI.obs.values.window,
xlab = "NDVI Observed Data",
ylab = "NDVI AR1 Forecast Data",
main = "Relationship Between Forecast and Observed NDVI Data from AR2 Model",
xlim = c(0.1,0.4),
ylim = c(0.1,0.4)
)
abline(a=0, b=1)
RMSE.pivot
ggplot(data = RMSE.pivot,
aes(x = forecast.dates,
y = RMSE,
group = name,
colour = name
)
) +
geom_point(size = 5) +
geom_line() +
labs(x = "Date",
title = "RMSE of Model Forecasts",
colour = "AR Model",
) +
theme(legend.position=c(0.2,0.8)) +
scale_colour_discrete(labels=c('AR1 Model', 'AR2 Model'))
RMSE.cumulative.ar2.model.forecast
NDVI.obs.values.window
NDVI.ar2.forecast
RMSE.cumulative.ar1.model.forecast
NDVI.obs.values.window
NDVI.ar1.forecast
sum((NDVI.obs.values.window-NDVI.obs.values.window)^2)
sum((NDVI.obs.values.window-NDVI.ar1.forecast)^2)
data3<-data
# Carry-over code from lab 3
n<-length(data3$NDVI)
datafit<-data3[1:(n-10),] #This is our "observed data; remove last 10
nfit<-length(datafit$NDVI)
model<-glm(NDVI[-1]~NDVI[-(nfit)],data=datafit) #AR model with single covariate (past NDVI)
# Model 1 (AR model [t-1])
b0 <- model$coefficients[1]
b1 <- model$coefficients[2]
y <- rep(NA, 10) #create an empty vector for future forloop
linear_model <- function(b0,b1,y){
future_ndvi <- b0+b1*y
}
y[1] <- datafit$NDVI[nfit] #use last observed NDVI value as the initial condition
#iterating through 10 months
for(i in 2: 11){
y[i] <- linear_model(b0=b0, b1=b1, y=y[i-1])
}
observed10 <- data3$NDVI[263:273] #last 10 observed NDVI values, previously withheld
# Model 2 (AR model [t-1] + rain)
raint_1 <- data3$rain[(n-10):(n-1)]
model2<-glm(NDVI[-1]~NDVI[-(nfit)]+rain[-(nfit)],data=datafit)
b0.2 <- model2$coefficients[1]
b1.2 <- model2$coefficients[2]
b2 <- model2$coefficients[3]
y.2 <- rep(NA, 10) #create an empty vector for future forloop
linear_model_v2 <- function(b0.2,b1.2,b2,y.2, y.rain){  #creating a forecasting function
future_ndvi_v2 <- b0.2+b1.2*y.2+b2*y.rain
}
y.2[1] <- datafit$NDVI[nfit]
for(i in 2: 11){
y.2[i] <- linear_model_v2(b0.2=b0.2, b1.2=b1.2, b2=b2, y.2 =y.2[i-1], y.rain=raint_1[i-1])
}
############# Lab 4 #############
y                                             #from previous data
yobs <- data3$NDVI[263:273]                   #last 10 observed NDVI values
t=(1:11)
rmse_mod1=rep(NA, 10)                         #empty vector for upcoming forloop
RMSE <- function(y,yobs,t){                   #rmse equation
rmse = sqrt((sum(y[1:t]-yobs[1:t])^2)/t)
}
for(i in 1:length(t)) {                       #model 1
rmse_mod1[i] <- RMSE(y=y, yobs=yobs, t=i)
}
y.2                                           #from previous data
yobs
rmse_mod2=rep(NA,10)
for(i in 1:length(t)) {                       #model 2
rmse_mod2[i] <- RMSE(y=y.2, yobs=yobs, t=i)
}
sum(rmse_mod1)                                #Model 1 (AR model)
sum(rmse_mod2)                                #Model 2 (AR model + rain) has a lower overall RMSE
# In model 1, the forecast diverges starting at month 6 and stays under-predicted
# through month 10. In model 2,the forecast diverges from observed values starting
# at month 6 but returns to similar values around month 9. This is due to the past
# rain covariate better explaining responses in NDVI values (in addition to past NDVI)
# than past NDVI values alone.
#Plots of predicted vs observed data
par(mfrow = c(2,1))
#model 1
plot(observed10, type="l", col="green", xlab="Months into the Future", ylab="Predicted NDVI",
main=expression("Model 1: Y ~ B"[0]*"+ B"[1]*"Y"[t-1]))
lines(y, type="b")
legend(1,0.36,c("Observed","Predicted"), lwd=c(2,2), col=c("green","black"), y.intersp=1.5,cex=0.7)
#model 2
plot(observed10, type="l", col="green", xlab="Months into the Future", ylab="Predicted NDVI",
main=expression("Model 2: Y ~ B"[0]*"+B"[1]*"Y"[t-1]*"+ B"[2]*"X"[rain(t-1)]))
lines(y.2, type="b")
rmse_mod1
rmse_mod2
head(data)
n<-length(data$NDVI)
#remove last 10
datafit<-data[1:(n-10),] ##This is our "observed data
nfit<-length(datafit$NDVI)
#Fit a AR(1) model to the NDVI observed data using the lm function.
#You will need to use indexing to match up NDVI at t with NDVI at t-1.
#(see example code below if you get stuck, but try it first and ask questions!!).
model<-glm(NDVI[-1]~NDVI[-(nfit)],data=datafit)
model
summary(model)
#Create a function to forecast the NDVI, and forecast the 10 months of the NDVI data that we witheld,
#treating the last observed value as your initial condition.
#Plot the forecast for the next ten months along points for the withheld data.
#This function will is very similar to logistic growth function we built in lab 1.
#You can extract the model parameters using model$coefficients.
# Yt = B0 + B1*Yt-1 + E
# where
# Yt = current year
# B0 = intercept
# B1 = slope
# Yt-1 = previous year
# E = error
Time = seq(1,11, by = 1)
B0 = as.numeric(model$coefficients[1])
B1 = as.numeric(model$coefficients[2])
#Create an “N” vector using rep(). I recommend filling it with zeros or NAs.
#To assign an initial value to N at time 1, use N[1] = .
n-10
#263
N = rep(NA, 11)
N[1] = data$NDVI[n-10]
for (i in 2:length(Time)) {
Yt <- N[i-1]
N[i] = B0 + B1*Yt
}
N
data$NDVI[263:273]
forecast1 <- data.frame(matrix(ncol = 2, nrow = 11))
colnames(forecast1) <- c('Time','NDVI')
forecast1$Time <- Time
forecast1$NDVI <- N
actualdata <- data.frame(matrix(ncol = 2, nrow = 11))
colnames(actualdata) <- c('Time','NDVI')
actualdata$Time <- Time
actualdata$NDVI <- data$NDVI[263:273]
ggplot() +
geom_line(data=actualdata, aes(x=Time, y=NDVI), color='green') +
geom_line(data=forecast1, aes(x=Time, y=NDVI), color='red')
#Repeat steps 1 & 2 using rain at t-1 along with NDVI at t-1 to explain NDVI at t.
model2<-glm(NDVI[-1]~NDVI[-(nfit)]+rain[-(nfit)],data=datafit)
model2
summary(model2)
plot(model2)
B0b = as.numeric(model2$coefficients[1])
B1b = as.numeric(model2$coefficients[2])
B2 = as.numeric(model2$coefficients[3])
raint_1<-data$rain[(n-10):(n-1)]
N2 = rep(NA, 11)
N2[1] = data$NDVI[n-10]
for (i in 2:length(Time)) {
Yt <- N2[i-1]
N2[i] = B0b + B1b*Yt + B2*raint_1[i-1]
}
N
N2
data$NDVI[263:273]
forecast2 <-  data.frame(matrix(ncol = 2, nrow = 11))
colnames(forecast2) <- c('Time','NDVI')
forecast2$Time <- Time
forecast2$NDVI <- N2
ggplot() +
geom_line(data=actualdata, aes(x=Time, y=NDVI), color='green') +
geom_line(data=forecast2, aes(x=Time, y=NDVI), color='blue')
ggplot() +
geom_line(data=actualdata, aes(x=Time, y=NDVI), color='green') +
geom_line(data=forecast1, aes(x=Time, y=NDVI), color='red') +
geom_line(data=forecast2, aes(x=Time, y=NDVI), color='blue')
############
#Cumulative RMSE calculation
#pred = forecasts (expected values or unknown results),
#obs = observed values (known results).
#N = sample size.
# the first value in both models is the actual NDVI,
# so including that would affect the RMSE since there
# won't be any difference
N[2:11]
N2[2:11]
data$NDVI[(n-10):n]
RMSE <- function(obs,pred,samp,t){
#set up 10 empty slots to hold RMSE
RMSEi<-numeric(t-1)
# 1 through t-1 because we have 11 points including the first value which is
# actual NDVI, not predicted
for (i in 1:t-1){
RMSEi[i] = sqrt((sum((pred[2:i+1] - obs[2:i+1])^2)/i))
#here we are starting at 2, since t=1 is actual NDVI and would skew RMSE
#we are then looping through to i + 1 since at time 1 we actually need 2
#this is a very convoluted way to do it but it's because our t = 1 is not
# a predicted value and therefore throws off every other iteration including
# our sample size n
#I could have done 1 / (i - 1) instead probably
#I also could have dropped the first value in our forecasts but it's helpful to see that
#starting value
}
return(RMSEi)
}
RMSE1 <- RMSE(obs = data$NDVI[(n-10):n],pred = N,t=11)
#get RMSE for our first forecast
RMSE1
RMSE2 <- RMSE(obs = data$NDVI[(n-10):n],pred = N2,t=11)
#get RMSE for our second forecast
RMSE2
di <- datafit$NDVI[263]
tn <- numeric(11)
tn[1] <- di
summary(tn)
summary(data$NDVI[263:273])
sqrt(mean((data$NDVI[263:273] - tn)^2))
#0.08902785
sqrt(mean((data$rain[263:273] - tn)^2))
#51.30926
time1 <- (2:11)
tn
actualn <-data$NDVI[263:273]
rmsemodel <- rep(NA, 11)
rmse <- function(tn, actualn, time1) {
rmse1 = sqrt((sum(tn[1:t]-actualn[1:t])^2/t))
}
for(i in 1:length(time1)) {
rmsemodel[i] <- rmse1(tn = tn, actualn = actualn, time1 = i)
}
# I cannot get lines 28- 29 to stop showing errors with or without {} so it wont run
rmse <- function(tn, actualn, time1) {
rmse1 = sqrt((sum(tn[1:t]-actualn[1:t])^2/t))
}
for(i in 1:length(time1)) {
rmsemodel[i] <- rmse(tn = tn, actualn = actualn, time1 = i)
}
rmsemodel
n<-length(data$NDVI)
n
#remove last 10
datafit<-data[1:(n-10),] ##This is our "observed data". taking out last 10 months to use later
# Step 1---
#Fit a AR(1) model to the NDVI observed data using the lm function.
#You will need to use indexing to match up NDVI at t with NDVI at t-1.
#(see example code below if you get stuck, but try it first and ask questions!!).
nfit<-length(datafit$NDVI) ## using just the 263 lines from OG data
model<-glm(NDVI[-1]~NDVI[-(nfit)],data=datafit) #Bob:###Fit glm, indexing removes the first and last years from reponse/explanatory
model
# Step 2---
#Create a function to forecast the NDVI, and forecast the 10 months of the NDVI
#data that we witheld, treating the last observed value as your initial condition.
#Plot the forecast for the next ten months along points for the withheld data.
#This function will is very similar to logistic growth function we built in lab 1.
#You can extract the model parameters using model$coefficients.
beta<-c(model$coefficients)
#####  one way to do it, but something is wrong here.... ---
armodel<- function(b0, b1, yt_1, t){
yt<- b0 + b1*(t-1)
return(yt)
}
t<- 10
y_out<-numeric(t)
y_out[1]<-datafit$NDVI[nfit]
for (i in 2:t){
y[i]<- armodel(b0=beta[1], b1=beta[2], y_out[i-1])
y_out[i]<-yt
}
### creating a for loop within a function, Bob's way---
AR_function<-function(b0,b1,yinit,t){
yout<-numeric(t) ##creates a list for the function to add info to, 10 spots
yout[1]<-yinit
for (i in 2:t){
yout[i]<-b0+b1*yout[i-1]
}
return(yout)
}
Forecast1<-AR_function(b0=beta[1],b1=beta[2],yinit=datafit$NDVI[nfit],t=11)
par(mfrow=c(2,1))
plot(1:11,Forecast1,ylab='NDVI',xlab='Month', type='l', ylim=c(0,.5))
points(data$NDVI[(n-10):n], col='red')
# Step 3 --
#Repeat steps 1 & 2 using rain at t-1 along with NDVI at t-1 to explain NDVI at t.
## B2 is precip
model2<-glm(NDVI[-1]~NDVI[-(nfit)]+rain[-(nfit)],data=datafit)
raint_1<-data$rain[(n-10):(n-1)]
beta_2<-c(model2$coefficients)
AR_func_rain<-function(b0,b1,b2,yinit,t){
y_out<-numeric(t)
y_out[1]<-yinit
for (i in 2:t){
y_out[i]<-b0+b1*y_out[i-1]+b2*raint_1[i-1]
}
return(y_out)
}
forecast2<-AR_func_rain(b0=beta_2[1], b1=beta_2[2], b2=beta_2[3], yinit=datafit$NDVI[nfit],t=11) # t=11 because t=1 is the first observed point
plot(1:11,forecast2,ylab='NDVI',xlab='Month', type='l',ylim=c(0,.5))
points(data$NDVI[(n-10):n], col='red')
######## end of lab 3########
###########
### calculate RSME of both NDVI forecasts##############
#######forecast 1 (without rain)
y_pred<- Forecast1
y_obs<- tail(data$NDVI, n=11)
RMSE_forecast1<-sqrt(sum((y_pred[1:11]-y_obs[1:11])^2)/11)
RMSE_forecast1
plot(y_obs, y_pred)
## observed data
observed<-tail(data$NDVI, n=11)
## predicted data
predicted<-Forecast1
## separate function and for loop, not working, try making a loop in a function...
rootmean<- function(pred, obsv, t){
sqrt(sum((pred[1:t]-obsv[1:t])^2)/t)
return(rmse_out)
}
t=10
obsv<-observed
pred<-predicted
for (i in 2:length(pred)){
rmse_out<-rootmean(pred[i], obsv[i])
print(paste("RMSE for month", i, ":", rmse_out))
}
## RSME function with a for loop inside, this works!
rmse_function <- function (ypred, yobs){
n <- length(ypred)
rmse_output <- numeric(n)
rmse_result <- character(n)
for (i in 1:n){
rmse_output[i] <- sqrt(sum((ypred[i] - yobs[i])^2)/n)
rmse_result[i] <- paste("Cumulative RMSE up to month", i, ":", rmse_output[i])
}
return(rmse_result)
}
rmse_function(ypred=Forecast1, yobs = obsv)
#### RMSE for forecast 2 (with rain) ######
y_pred_rain<-forecast2
y_obs_rain<-tail(data$NDVI, n=11)
RMSE_forecast2<-sqrt((sum(y_pred_rain[1:11]-y_obs_rain[1:11])^2)/11)
RMSE_forecast2
#using my RSME function for NDVI forecast with rain
rmse_function(ypred = y_pred_rain, yobs = y_obs_rain)
plot(y_obs_rain,y_pred_rain) #plot of forecast 2
plot(y_obs, y_pred) # plot of forecast 1
#They start to diverge around month 6/7
### They diverge because there is more information in forecast 2 to go off of to make predictions.
# I.e. rain is more predicative of what NDVI will be like in the near future
library(lubridate)
NDVI_data<-data
# removing last 10 of data (we are going to forecast this later)
n <- length(NDVI_data$NDVI) # getting length of NDVI dataset
NDVI_data_new <- NDVI_data[1:(n-10),] # creating new dataset with last 10 removed
#### Question 1 ####
# we need to use indexing to match up NDVI at t with NDVI at t-1
n_new <- length(NDVI_data_new$NDVI) # need total length of vector to remove last value
# glm model below matches vector with first row removing as y to vector with
# last row removing as x
model <- glm(NDVI[-1]~NDVI[-n_new], data = NDVI_data_new)
# in other words, NDVI[-1] represents t and NDVI[-n_new] represents t-1
#### Question 2 ####
# to get coefficients from above model
b <- model$coefficients[1]
m <- model$coefficients[2]
# forecasting model will be: y(t) = b + m*y(t-1)
# x axis will be time and y will be NDVI
# initial condition is our last observed value
# we are forecasting last 10 months/values which we withheld above
# making time vector as 11 for 10 months plus initial state
forecasted <- data.frame("Time" = rep(NA, 11), # making empty dataframe for forecasting
"NDVI" = rep(NA, 11)) # one more than 10 to plot initial value
forecasted$Time <- NDVI_data$date[(n-10):n] # putting in last 11 dates from original data
forecasted$NDVI[1] <- NDVI_data_new$NDVI[n_new] # assigning initial condition
# creating forecast function
forecast_func <- function(b, m, t) {
new <- b + m * t # given equation
return(new) # returns forecasted value
}
# "for" loop to go through time and forecast
for (i in 2:11) {
forecasted$NDVI[i] <- forecast_func(b = b, m = m, t = forecasted$NDVI[(i-1)])
}
# plotting what was forecast
forecasted$Time <- mdy(forecasted$Time)
plot(x = forecasted$Time[2:11], y = NDVI_data$NDVI[(n-9): n], col = "blue")
points(x = forecasted$Time[2:11], y = forecasted$NDVI[2:11], col = "red")
legend(x = "topleft", legend = c("Withheld Data", "Forecasted Value"),
fill = c("blue", "red"))
#### Question 3 ####
# we need to make a linear model that predicts NDVI as a response to prior NDVI AND rain
# again, glm model below matches NDVI vector with first row removing as y to NDVI and rain
# vectors with last row removing as x
model2 <- glm(NDVI[-1] ~ NDVI[-n_new] + rain[-n_new], data = NDVI_data_new)
# to get coefficients from above model
b2 <- model2$coefficients[1]
m2_NDVI <- model2$coefficients[2]
m2_rain <- model2$coefficients[3]
# forecasting model will be: y(t) = b + (m_NDVI)*NDVI(t-1) + (m_rain)*rain(t-1)
# we are not forecasting the rain, this data will be known
# x axis will be time and y will be NDVI
# initial condition is our last observed value
# we are forecasting last 10 months/values which we withheld above
# making time vector as 11 for 10 months plus initial state
forecasted2 <- data.frame("Time" = rep(NA, 11), # making empty dataframe for forecasting
"NDVI" = rep(NA, 11), # one more than 10 to plot initial value
"Rain" = rep(NA, 11))
forecasted2$Time <- NDVI_data$date[(n-10):n] # putting in last 11 dates from original data
forecasted2$Rain <- NDVI_data$rain[(n-10):n] # putting in last 11 rain measurements from original data
forecasted2$NDVI[1] <- NDVI_data_new$NDVI[n_new] # assigning initial condition
# creating forecast function
forecast2_func <- function(b, m_NDVI, m_rain, t) {
# equation used below to forecast value
new <- b + (m_NDVI * forecasted2$NDVI[(t-1)]) + (m_rain * forecasted2$Rain[(t-1)])
return(new) # returns forecasted value
}
# "for" loop to go through time and forecast
for (i in 2:11) {
forecasted2$NDVI[i] <- forecast2_func(b = b2, m_NDVI = m2_NDVI,
m_rain = m2_rain, t = i)
}
# plotting what was forecasted with model 2
forecasted2$Time <- mdy(forecasted2$Time)
plot(x = forecasted2$Time[2:11], y = NDVI_data$NDVI[(n-9): n], col = "green")
points(x = forecasted2$Time[2:11], y = forecasted2$NDVI[2:11], col = "purple")
legend(x = "topleft", legend = c("Withheld Data", "Forecasted Value"),
fill = c("green", "purple"))
# so our predictions got better by including rain
#### RMSE Assignment (Lab 4) ####
# in class assignment: calculate RMSE of both NDVI forecasts (02.09.2023)
# RMSE = sqrt((1/n)sum((ypred - ydata)^2))
## first forecast that only uses NDVI model (no rain), "forecasted"
# taking last 11 values of NDVI_data to make this easier
NDVI_data_test <- NDVI_data$NDVI[(n-9):n]
RMSE_forecasted <- data.frame("Time" = (1:10),
"RMSE" = rep(NA, 10),
"pred_mins_obs" = rep(NA,10))
# for loop to fill in data frame
for (i in 2:11) {
RMSE_forecasted$pred_mins_obs[i-1] <- (forecasted$NDVI[i]-NDVI_data_test[i-1])
cont_sum <- sum((forecasted$NDVI[2:i]-NDVI_data_test[1:(i-1)])^2)
RMSE_forecasted$RMSE[i-1] <- sqrt(((1/(i-1))*(cont_sum)))
}
## second forecast that only uses NDVI & rain model, "forecasted2"
# taking last 11 values of NDVI_data to make this easier
RMSE_forecasted2 <- data.frame("Time" = (1:10),
"RDSE" = rep(NA, 10),
"pred_mins_obs" = rep(NA,10))
# for loop to fill in data frame
for (i in 2:11) {
RMSE_forecasted2$pred_mins_obs[i-1] <- (forecasted2$NDVI[i]-NDVI_data_test[i-1])
cont_sum <- sum((forecasted2$NDVI[2:i]-NDVI_data_test[1:(i-1)])^2)
RMSE_forecasted2$RDSE[i-1] <- sqrt(((1/(i-1))*(cont_sum)))
}
# forecast model 2 is better at each step
# this is especially true at the first three months
# forecast model 2 starts to do worse at month 4
# at month 6 the two are quite close
# but at months 8-10 forecast model 1 is much worse
## Creating predicted vs. observed plots
#par(mfrow = c(2, 1))
# forecast plot 1 (difference / residuals)
plot(x = RMSE_forecasted$Time, y = RMSE_forecasted$pred_mins_obs)
abline(h=0, col = "red")
# forecast plot 1 (predicted vs observed)
plot(y = forecasted$NDVI[2:11], x = NDVI_data$NDVI[(n-9):n], ylim = c(0,0.4), xlim = c(0, 0.4))
abline(a = 0, b = 1, col ="red")
# forecast plot 2 (difference / residuals)
plot(x = RMSE_forecasted2$Time, y = RMSE_forecasted2$pred_mins_obs)
abline(h=0, col = "red")
# forecast plot 2 (predicted vs observed)
plot(y = forecasted2$NDVI[2:11], x = NDVI_data$NDVI[(n-9):n], ylim = c(0,0.4), xlim = c(0, 0.4))
abline(a = 0, b = 1, col = "red")
plot(x = RMSE_forecasted2$Time, y = RMSE_forecasted2$pred_mins_obs)
abline(h=0, col = "red")
RMSE_forecasted2$RDSE
RMSE_forecasted$RMSE
